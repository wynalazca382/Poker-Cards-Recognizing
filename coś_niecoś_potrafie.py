# -*- coding: utf-8 -*-
"""coś niecoś potrafie.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LslLda0WSvg__Y5eZyRIM8-bIPIKneiT
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, OneHotEncoder, MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten, Dropout, Activation, Conv1D, MaxPooling1D
from keras.utils import to_categorical
from sklearn.model_selection import train_test_split

df = pd.read_csv('poker-hand-training-true.data', header=None)

X = df.iloc[:, :10]
y = df.iloc[:, 10]

suit_encoder = OneHotEncoder(sparse=False)
X_suit = suit_encoder.fit_transform(X.iloc[:, ::2].values.reshape(-1, 1))
X_suit = X_suit.reshape(-1, 5, 4)

rank_scaler = MinMaxScaler()
X_rank = rank_scaler.fit_transform(X.iloc[:, 1::2].values.reshape(-1, 1))
X_rank = X_rank.reshape(-1, 5, 1)

X = np.concatenate((X_suit, X_rank), axis=2)

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(y)

X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=True)

model = Sequential()
model.add(Conv1D(64, kernel_size=3, activation='relu', input_shape=(5, 5)))
model.add(MaxPooling1D(pool_size=1))
model.add(Conv1D(128, kernel_size=3, activation='relu'))
model.add(MaxPooling1D(pool_size=1))
model.add(Flatten())
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(num_classes, activation='softmax'))

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

model.fit(X_train, y_train, epochs=100, validation_data=(X_val, y_val), batch_size=128, verbose=1)

df_test = pd.read_csv('poker-hand-testing.data', header=None)

X_test = df_test.iloc[:, :10]
y_test = df_test.iloc[:, 10]

X_suit_test = suit_encoder.transform(X_test.iloc[:, ::2].values.reshape(-1, 1))
X_suit_test = X_suit_test.reshape(-1, 5, 4)

X_rank_test = rank_scaler.transform(X_test.iloc[:, 1::2].values.reshape(-1, 1))
X_rank_test = X_rank_test.reshape(-1, 5, 1)

X_test = np.concatenate((X_suit_test, X_rank_test), axis=2)

y_test_encoded = label_encoder.transform(y_test)

loss, accuracy = model.evaluate(X_test, y_test_encoded, batch_size=None, verbose=1)
print(f'Testing loss: {loss:.4f}')
print(f'Testing accuracy: {accuracy:.4f}')

df_test = pd.read_csv('poker-hand-training-true.data', header=None)

# Preprocess the testing data
X_test = df_test.iloc[:, :10]  # predictive attributes
y_test = df_test.iloc[:, 10] # goal attribute

# One-hot encode the suit attributes
X_suit_test = suit_encoder.transform(X_test.iloc[:, ::2].values.reshape(-1, 1))
X_suit_test = X_suit_test.reshape(-1, 5, 4)  # 5 cards, 4 suits each

# Scale the rank attributes
X_rank_test = rank_scaler.transform(X_test.iloc[:, 1::2].values.reshape(-1, 1))
X_rank_test = X_rank_test.reshape(-1, 5, 1)  # 5 cards, 1 rank

# Concatenate the suit and rank features
X_test = np.concatenate((X_suit_test, X_rank_test), axis=2)

# Label encode and transform the test labels
y_test_encoded = label_encoder.transform(y_test)

# Evaluate the model
loss, accuracy = model.evaluate(X_test, y_test_encoded, batch_size=None, verbose=1)
print(f'Testing loss: {loss:.4f}')
print(f'Testing accuracy: {accuracy:.4f}')

"""finalna *wersja* - zmiana ilości rąk testowych i treningowych miejscam"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, OneHotEncoder, MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten, Dropout, Activation, Conv1D, MaxPooling1D
from keras.utils import to_categorical
from sklearn.model_selection import train_test_split

df = pd.read_csv('poker-hand-testing.data', header=None)

X = df.iloc[:, :10]
y = df.iloc[:, 10]

suit_encoder = OneHotEncoder(sparse=False)
X_suit = suit_encoder.fit_transform(X.iloc[:, ::2].values.reshape(-1, 1))
X_suit = X_suit.reshape(-1, 5, 4)

rank_scaler = MinMaxScaler()
X_rank = rank_scaler.fit_transform(X.iloc[:, 1::2].values.reshape(-1, 1))
X_rank = X_rank.reshape(-1, 5, 1)

X = np.concatenate((X_suit, X_rank), axis=2)

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(y)

X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=True)

model = Sequential()
model.add(Conv1D(64, kernel_size=3, activation='relu', input_shape=(5, 5)))
model.add(MaxPooling1D(pool_size=1))
model.add(Conv1D(128, kernel_size=3, activation='relu'))
model.add(MaxPooling1D(pool_size=1))
model.add(Flatten())
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(num_classes, activation='softmax'))

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

model.fit(X_train, y_train, epochs=100, validation_data=(X_val, y_val), batch_size=128, verbose=1)

df_test = pd.read_csv('poker-hand-training-true.data', header=None)

X_test = df_test.iloc[:, :10]
y_test = df_test.iloc[:, 10]

X_suit_test = suit_encoder.transform(X_test.iloc[:, ::2].values.reshape(-1, 1))
X_suit_test = X_suit_test.reshape(-1, 5, 4)

X_rank_test = rank_scaler.transform(X_test.iloc[:, 1::2].values.reshape(-1, 1))
X_rank_test = X_rank_test.reshape(-1, 5, 1)

X_test = np.concatenate((X_suit_test, X_rank_test), axis=2)

y_test_encoded = label_encoder.transform(y_test)

loss, accuracy = model.evaluate(X_test, y_test_encoded, batch_size=None, verbose=1)
print(f'Testing loss: {loss:.4f}')
print(f'Testing accuracy: {accuracy:.4f}')

model.save("poker_hand_model.h5")

import numpy as np
from tensorflow.keras.models import load_model

def encode_card(rank, suit):
    rank_mapping = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}
    suit_mapping = {'C': [1, 0, 0, 0], 'D': [0, 1, 0, 0], 'H': [0, 0, 1, 0], 'S': [0, 0, 0, 1]}
    return np.concatenate((suit_mapping[suit], [rank_mapping[rank]]))

def main():
    # Wczytanie wytrenowanego modelu
    model = load_model('poker_hand_model.h5')

    # Pobranie danych kart od użytkownika
    cards = []
    for i in range(5):
        rank = input(f"Podaj rangę karty {i+1} (A, 2-10, J, Q, K): ").upper()
        suit = input(f"Podaj kolor karty {i+1} (C, D, H, S): ").upper()
        cards.append((rank, suit))

    # Zakodowanie kart do formatu używanego przez model
    encoded_cards = []
    for rank, suit in cards:
        encoded_cards.append(encode_card(rank, suit))
    X_input = np.array(encoded_cards).reshape(1, 5, 5)

    # Określenie ręki
    prediction = model.predict(X_input)
    hand_classes = ['Nic', 'Parę', 'Dwie pary', 'Trójki', 'Strit', 'Kolor', 'Full', 'Poker', 'Poker królewski']
    predicted_class = np.argmax(prediction)
    print(f"Twoja ręka to: {hand_classes[predicted_class]}")

if __name__ == "__main__":
    main()

import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder, MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten, Dropout, Activation, Conv1D, MaxPooling1D
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split

# Load data
df = pd.read_csv('poker-hand-testing.csv', header=0)

print(df.head(10))
# Split data into features and target
X = df.iloc[:, :10]
y = df.iloc[:, 10]

# One-hot encode suits
suit_encoder = OneHotEncoder(sparse=False)
X_suit = suit_encoder.fit_transform(X.iloc[:, ::2].values.reshape(-1, 1))
X_suit = X_suit.reshape(-1, 5, 4)

# Scale ranks
rank_scaler = MinMaxScaler()
X_rank = rank_scaler.fit_transform(X.iloc[:, 1::2].values.reshape(-1, 1))
X_rank = X_rank.reshape(-1, 5, 1)

# Concatenate suits and ranks
X = np.concatenate((X_suit, X_rank), axis=2)

# One-hot encode target variable
num_classes = len(np.unique(y))
y = to_categorical(y, num_classes)

# Split data into training and validation sets
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=True)

# Define model
model = Sequential()
model.add(Conv1D(64, kernel_size=3, activation='relu', input_shape=(5, 5)))
model.add(MaxPooling1D(pool_size=1))
model.add(Conv1D(128, kernel_size=3, activation='relu'))
model.add(MaxPooling1D(pool_size=1))
model.add(Flatten())
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(num_classes, activation='softmax'))

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Define early stopping callback
early_stopping = EarlyStopping(monitor='val_loss', patience=10)

# Train model
model.fit(X_train, y_train, epochs=10, validation_data=(X_val, y_val), batch_size=128, verbose=1, callbacks=[early_stopping])

# Evaluate model on test data
df_test = pd.read_csv('poker-hand-training.csv', header=0)
X_test = df_test.iloc[:, :10]
y_test = df_test.iloc[:, 10]

X_suit_test = suit_encoder.transform(X_test.iloc[:, ::2].values.reshape(-1, 1))
X_suit_test = X_suit_test.reshape(-1, 5, 4)

X_rank_test = rank_scaler.transform(X_test.iloc[:, 1::2].values.reshape(-1, 1))
X_rank_test = X_rank_test.reshape(-1, 5, 1)

X_test = np.concatenate((X_suit_test, X_rank_test), axis=2)

y_test = to_categorical(y_test, num_classes)

loss, accuracy = model.evaluate(X_test, y_test, batch_size=None, verbose=1)
print(f'Testing loss: {loss:.4f}')
print(f'Testing accuracy: {accuracy:.4f}')

# Save model
model.save("poker_hand_model.h5")

import numpy as np
from tensorflow.keras.models import load_model

def encode_card(rank, suit):
    rank_mapping = {'Ace': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'Jack': 11, 'Queen': 12, 'King': 13}
    suit_mapping = {'Hearts': [1, 0, 0, 0], 'Spades': [0, 1, 0, 0], 'Diamonds': [0, 0, 1, 0], 'Clubs': [0, 0, 0, 1]}
    return np.concatenate((suit_mapping[suit], [rank_mapping[str(rank)]]))

def predict_poker_hand(model, cards):
    suit_strings = ['Hearts', 'Spades', 'Diamonds', 'Clubs']
    encoded_cards = []
    for rank, suit in cards:
        encoded_cards.append(encode_card(rank, suit))
    X_input = np.array(encoded_cards).reshape(1, 5, 5)
    prediction = model.predict(X_input)
    predicted_class = np.argmax(prediction)
    hand_classes = ['Nothing in hand', 'One pair', 'Two pairs', 'Three of a kind', 'Straight', 'Flush', 'Full house', 'Four of a kind', 'Straight flush', 'Royal flush']
    return hand_classes[predicted_class]

# Load the saved model
model = load_model('poker_hand_model.h5')

# Example input
cards = [('Ace', 'Hearts'), ('Ace', 'Diamonds'), ('Ace', 'Spades'), (6, 'Clubs'), (5, 'Diamonds')]

# Predict the poker hand
predicted_hand = predict_poker_hand(model, cards)
print(predicted_hand)